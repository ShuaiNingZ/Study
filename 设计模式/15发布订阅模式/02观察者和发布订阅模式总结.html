<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>
    /**
     * 观察者模式: 观察者、被观察者, 重点是被观察者
     * 关系: 被观察者至少有三个方法-添加观察者、移除观察者、通知观察者,
     *      被观察者将观察者添加到自己的观察列表来建立关系, 观察者也可
     *      以主动申请加入被观察者的观察列表, 此后被观察者触发通知观察
     *      者方法, 观察者即可接收到来自被观察者的消息
     *
     * 发布订阅模式: 发布者、订阅者、发布订阅中心, 重点是发布订阅中心
     * 关系: 发布订阅核心基于一个中心来建立整个体系. 发布者将发布的消息
     *      交给发布订阅中心管理, 订阅者根据自己的情况, 按需订阅中心中
     *      的消息.
     * 案例: 邮箱系统
     *      订阅者: 自己订阅某个网站的通知
     *      发布订阅中心: 邮件系统
     *      发布者: 自己订阅的网站
     *      整个链路是从你的订阅开始, 虽然在你订阅之前, 别人可能已经订阅过
     *      某些网站并不断接收来自网站更新所发出的消息. 你的订阅动作是在某个
     *      你想订阅的网站填入自己的邮箱, 如果这一步以邮箱系统为中心, 那么则
     *      是在的邮箱内记录这个网站信息, 后续当网站有内容更新时, 邮件系统会
     *      及时接收到并向你发送邮件, 以达到通知你这个订阅者的目的
     *
     * 1. 降级为观察者模式
     *      这里说的是以邮箱系统为中心, 假如以网站为中心, 那么你对于网站就相当于一个观察者, 你希望
     *      观察网站的一举一动, 即网站内容的更新. 那么订阅动作本身便成了你让网站将你的邮箱加入网站
     *      维护的观察者列表. 这样当网站有内容更新后, 便会通知所有观察者, 也就是订阅者, 这时发布订阅
     *      模型则退化为观察者模式
     *
     * 2. 升级为发布订阅
     *      可以看出, 此时网站和用户间其实是有耦合的, 也就是网站除了要维护自身功能外, 还需要维护订阅者
     *      列表, 并且在内容更新后完成通知工作. 这样在用户和网站之间有一部分关系是维护在网站内部的. 如果
     *      网站想吧这部分任务抽离出来, 自然便恢复至发布订阅模式, 即建立单独的消息中心来管理发布者和订阅者
     *      之间的关系以及接收变化和通知消息的工作.
     *      经过这样的对比, 我们可以知道为什么要区分观察者
     * 3. 与观察者模式的关联
     *      但是发布订阅真的和观察者模式是割裂开来的吗? 并不是
     *      其实发布订阅的实现内部利用了 观察者模式, 让我们回顾一下观察者模式的核心, 观察者模式由观察者和被
     *      观察者组成, 其中被观察者是重点. 二者的关联可以是在创建被观察者后, 调用其添加观察者方法主动建立和
     *      某个观察者的关系, 或是在创建观察者时即声明要观察的对象, 即被观察者. 其中观察者和被观察者一般为一对多
     *      关系, 即一个被观察者可以被多个观察者观察.
     *      那么分析发布订阅模型即可发现, 其中 订阅者 和 发布订阅中心 的关系类似 观察者 和 被观察者 的关系.
     *      注意只是类似, 因为虽然其中 订阅者 和 观察者 都是消费的一方, 期待能够即时接收到其他地方的变化.
     *
     *      但区别在于观察者模式中的被观察者需要在每次自身改变后都绑定式地触发对观察者的通知, 因为这是观察者模式
     *      这一模式所要实现的核心, 也就是类似事件处理机制, 被观察者有义务针对自身的变化给出响应式的反馈到观察者们,
     *      这就是为什么说观察者模式是松耦合的, 因为被观察者的功能不纯粹, 要包含一部分观察者和自身关系的逻辑.
     *
     *      而发布订阅与之的区别在于, 因为发布者把消息通知的权限交由发布订阅中心管理, 发布者只需关心自身的发布逻辑,
     *      而不会直接和其所发布内容的订阅者直接通信, 订阅者也如此, 其只关心向发布订阅中心注册自己想要接收通知的栏目,
     *      并实现自己在接收到通知后的逻辑, 而无需关心消息来自何方, 发布者是谁. 因此发布者和订阅者由于发布订阅中心的
     *      出现而完全解耦
     *
     *      由于发布订阅中心这一中间层的出现, 对于生产方和消费方的通信管理变得更加的可管理和可拓展. 比如这样同样可以
     *      实现通过观察者模式实现的事件机制, 即消息中心在接收到新的消息发布后即时通知到该类目下的所有订阅者, 只不过此时
     *      的发布者与消息中心的关系为一对一, 并且消息中心与订阅者的一对多, 消息中心只相当于发布者的一层代理
     *
     *      以上发布订阅中心、发布者和订阅者三者有各自的实现, 其中发布者和订阅者实现比较简单, 只需要完成各自发布、订阅的
     *      任务即可. 其中订阅者可以在接收到消息后做后续处理. 重点在于二者需要确保在与同一个发布订阅中心进行关联, 否则两者
     *      之间的通知无法关联
     *
     * 实际应用:
     *      在实际应用中, 对于以上二者的实现可能会更加的复杂, 同时也会根据各自的场景进行变形, 所以大可不息拘泥于二者的标准实现.
     *      因为不论是设计模式还是技术模型大多都只是前人根据经验总结而成的编程思想, 知道他们可能会对某些复杂问题的解决有启发性的
     *      帮助, 进而借助这类思想巧妙地解决特定场景的问题.
     *      至于具体应用如下实践,
     *          Node.js 中自带的 EventEmiter 模块
     *          Vue.js 数据响应式的实现
     *      其他比如你在代码中发现有 watch、watcher、observer、listen、listener、dispatch、trigger、emit、on、event、
     *      eventbus、EventEmitter 这类单词出现的地方, 很有可能是在使用 观察者模式 或 发布订阅 的思想. 等下次你发现有这些词的
     *      时候, 不妨点进他的源码看看其他 coder 在实现 观察者模式 或 发布订阅 时有哪些巧妙的细节
     *
     */
</script>
</body>
</html>
