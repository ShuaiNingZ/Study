<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>
    /**
     * 外观模式是指提供一个统一的接口去访问多个子系统的多个不同的接口, 为子系统中的一组接口
     * 提供统一的高层接口. 使得子系统更容易使用, 不仅简化类中的接口, 而且实现调用者和接口的解耦
     */

    /* a.js */
    export default {
        getA(params) {

        }
    }

    /* b.js */
    export default {
        getB(params) {

        }
    }

    // index.js 外观模式为子系统提供同一的高层接口
    import A from './a';
    import B from './b';

    export default {
        A,
        B
    }

    // 通过同一接口调用子系统
    import app from './app';

    app.A.getA(params);
    app.B.getB(params);

    /**
     * 与适配器模式的区别:
     * 适配器模式是将一个对象包装起来以改变其接口, 而外观模式是将一群对象包装起来以简化其接口.
     * 适配器时将接口转换为不同接口, 外观模式是提供一个统一的接口来简化接口.
     *
     * 外观模式:
     * 外部与一个子系统的通信必须通过一个统一的门面对象进行, 这就是门面模式.
     * 外观模式为子系统提供了统一的界面, 屏蔽了子类的不同.
     * 现代大型软件发展到一定程度会非常复杂, 于是就需要对软件进行模块化开发, 将系统分成各个模块,
     * 有利于维护和拓展, 但即使这样在我们调用的时候依然要和许多类打交道, 依然很复杂, 于是外观模式
     * 应运而生, 外观模式就是为多个子系统提供一个统一的外观类来简化外部人员操作
     *
     * 外观模式设计两种对象:
     * 外观类: 客户端调用这个角色的方法. 此角色知晓相关的子系统的功能和责任. 正常情况下, 本角色会将
     * 所有从客户端发来的请求委派到响应的子系统中去.
     * 子系统类: 可以同时有一个或者多个子系统. 每个子系统都不是一个单独的类, 而是一个类的集合. 每个
     * 子系统都可以被客户端直接调用, 或者被门面角色直接调用. 子系统并不知道门面的存在, 对于子系统而言,
     * 门面仅仅是拎一个客户端而已.
     * 外观模式结构, 客户端正常调用方式
     */
</script>
</body>
</html>
