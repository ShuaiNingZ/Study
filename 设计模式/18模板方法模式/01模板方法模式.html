<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>
    /**
     * 模板方法模式:
     * 由 抽象父类、具体实现子类 构成
     * 通常在抽象父类中封装子类的算法框架, 包括实现一些公共方法以及封装子类中所有方法的执行顺序.
     * 子类通过继承这个抽象类, 也继承了整个算法解构, 并且可以选择重写父类的方法.
     * 抽象类: 不能被实例化的类, 一定是用来继承的. 继承了抽象类的所有子类都将拥有跟抽象类一致的接口方法,
     *        抽象类的主要作用就是为他的子类定义这些公共接口.
     */

    const Container = function (params = {}) {
        let F = function () {
        }

        F.prototype.getData = params.getData || function () {
            throw new Error('必须传入 getData');
        }

        F.prototype.render = function () {
            console.log('render');
        }

        F.prototype.init = function () {
            this.getData();
            this.render()
        }

        return F
    }

    const MyClass = Container({
        getData() {
            console.log('MyClass');
            return [1, 2, 3]
        }
    })

    new MyClass().init();


    const MyClass1 = Container({
        getData() {
            console.log('MyClass1')
            return [4, 5, 6]
        }
    })
    new MyClass1().init()

</script>
</body>
</html>
