exports.x = 'a1';

console.log('a.js', require('./b.js').x);

exports.x = 'a2';

// console.log('a.js', require.main === oldModule);

/**
 * 计算机系统中 I/O 就是 输入(Input) 和 输出(Output) 的意思
 * 针对不同的操作对象, 可以划分为磁盘 I/O 模型, 网络 I/O 模型, 内存映射 I/O, 数据库 I/O等,
 * 只要具有输入输出类型的交互系统都可以认为是 I/O 系统, 也可以说 I/O 是整个操作系统数据交换与
 * 人机交互的通道, 这个概念与开发语言没有关系, 是一个通用的概念
 * BIO (Blocking I/O): 同步阻塞 I/O 模型
 * 线程再执行中, 遇到磁盘读写或者网络通信, 通常要消耗较长的事件, 这时操作系统
 * 会剥夺这个线程的 CPU 控制权, 使其暂停执行, 同时将资源让给其他的工作线程, 这样线程
 * 调度方式成为阻塞. 当 I/O 操作完毕时, 操作系统将这个线程的阻塞状态解除, 恢复其对 CPU
 * 的控制权, 令其继续执行
 * AIO (Asynchronous I/O): 异步非阻塞 I/O 模型
 * 针对所有的 I/O 操作不采取阻塞策略, 当遇到 I/O 操作时, 不会以阻塞的方式等待 I/O 操作
 * 的完成, 而是将 I/O 请求发送给操作系统, 继续执行下一条语句, 当操作系统完成 I/O 操作时,
 * 以事件的形式通知执行 I/O 操作的线程, 线程会再特定的时候处理这个事件, 为了处理异步 I/O,
 * 线程必须有事件循环, 不断地检查有没有未处理的事件, 依次予以处理
 */

/**
 * 单线程事件驱动的异步式 I/O 比传统的多线程阻塞式 I/O 优点:
 * 异步式 I/O 少了多线程的开销, 对操作系统来说, 创建一个线程的代价是十分昂贵的, 需要分配内存, 列入调入,
 * 同时在线程切换的时候还要执行内存换页, CPU 的缓存被清空, 切换回来的时候还要重新从内存中读取信息, 破坏
 * 数据的局部性
 */

/**
 * nodejs 程序由事件循环开始, 到事件循环结束, 所有的逻辑都是事件的回调函数, 所以 nodejs 始终在事件循环
 * 中, 程序入口就是事件循环第一个事件的回调函数.
 * 事件的回调函数在执行的过程中, 可能会发出 I/O 请求或直接发射 emit 事件, 执行完毕后再返回事件循环, 事
 * 件循环会检查事件队列中有没有未处理的事件, 直到程序结束
 */